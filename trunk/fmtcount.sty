
%\subsection{fmtcount.sty}
% This section deals with the code for |fmtcount.sty|
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{fmtcount}[2020/01/30 v3.06]
\RequirePackage{ifthen}
%    \end{macrocode}
% \changes{3.01}{2014/12/03}{Use \styfmt{xkeyval} instead of \styfmt{keyval}, so that we do not get in trouble
% with bracket spurious removals}
%    \begin{macrocode}
\RequirePackage{xkeyval}
\RequirePackage{etoolbox}
\RequirePackage{fcprefix}
%    \end{macrocode}
% \changes{3.00}{2014/07/3}{Add \cs{RequirePackage} for \texttt{ifxetex}}
% \changes{3.05}{2017/12/24}{Stop using \cs{ifxetex} to trigger multilingual mode. Instead only packages are
% tested for being loaded.}
% \changes{1.3}{2007/7/19}{no longer using xspace package}
%\changes{1.31}{2009/10/02}{amsgen now loaded (\cs{new@ifnextchar}
% needed)}
% Need to use \cs{new@ifnextchar} instead of \cs{@ifnextchar} in
% commands that have a final optional argument (such as \cs{gls})
% so require \sty{amsgen}.
%    \begin{macrocode}
\RequirePackage{amsgen}
%    \end{macrocode}
% These commands need to be defined before the
% configuration file is loaded.
%
% Define the macro to format the |st|, |nd|, |rd| or |th| of an 
% ordinal.
% \changes{3.01}{2014/12/3}{Make \cs{fmtord} language dependent.}
% \changes{3.01}{2014/12/3}{Substitute \cs{textsuperscript} for \cs{fc@textsuperscript}, and define
% \cs{fc@textsuperscript} as \cs{fup} when defined at beginning of document, or as \cs{textsuperscript}
% otherwise}
%\begin{macro}{\fc@orddef@ult}
%    \begin{macrocode}
\providecommand*{\fc@orddef@ult}[1]{\fc@textsuperscript{#1}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\fc@ord@multiling}
%    \begin{macrocode}
\providecommand*{\fc@ord@multiling}[1]{%
  \ifcsundef{fc@\languagename @alias@of}{%
%    \end{macrocode}
% Not a supported language, just use the default setting:
%    \begin{macrocode}
  \fc@orddef@ult{#1}}{%
  \expandafter\let\expandafter\@tempa\csname fc@\languagename @alias@of\endcsname
  \ifcsundef{fc@ord@\@tempa}{%
%    \end{macrocode}
% Not language specfic setting, just use the default setting:
%    \begin{macrocode}
    \fc@orddef@ult{#1}}{%
%    \end{macrocode}
% Language with specific setting, use that setting:
%    \begin{macrocode}
\csname fc@ord@\@tempa\endcsname{#1}}}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\padzeroes}
%\begin{definition}
%\cs{padzeroes}\oarg{n}
%\end{definition}
% Specifies how many digits should be displayed for commands such as
% \cs{decimal} and \cs{binary}.
%    \begin{macrocode}
\newcount\c@padzeroesN
\c@padzeroesN=1\relax
\providecommand*{\padzeroes}[1][17]{\c@padzeroesN=#1}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\FCloadlang}
%\changes{2.0}{2012/06/3}{new}
%\changes{2.02}{2012/10/3}{ensured catcode for @ set to `letter'
%before loading file}
%\begin{definition}
%\cs{FCloadlang}\marg{language}
%\end{definition}
% Load \styfmt{fmtcount} language file,
% \texttt{fc-}\meta{language}\texttt{.def}, unless already loaded.
% Unfortunately neither \styfmt{babel} nor \styfmt{polyglossia} keep a list of loaded
% dialects, so we can't load all the necessary def files in the
% preamble as we don't know which dialects the user requires.
% Therefore the dialect definitions get loaded when a command such
% as \cs{ordinalnum} is used, if they
% haven't already been loaded.
%    \begin{macrocode}
\newcount\fc@tmpcatcode
\def\fc@languages{}%
\def\fc@mainlang{}%
\newcommand*{\FCloadlang}[1]{%
  \@FC@iflangloaded{#1}{}%
  {%
    \fc@tmpcatcode=\catcode`\@\relax
    \catcode `\@ 11\relax
    \InputIfFileExists{fc-#1.def}%
    {%
      \ifdefempty{\fc@languages}%
      {%
        \gdef\fc@languages{#1}%
      }%
      {%
         \gappto\fc@languages{,#1}%
      }%
      \gdef\fc@mainlang{#1}%
    }%
    {}%
    \catcode `\@ \fc@tmpcatcode\relax
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@FC@iflangloaded}
%\changes{2.0}{2012/06/3}{new}
%\begin{definition}
%\cs{@FC@iflangloaded}\marg{language}\marg{true}\marg{false}
%\end{definition}
%If fmtcount language definition file \texttt{fc-}\meta{language}\texttt{.def} has
%been loaded, do \meta{true} otherwise do \meta{false}
%    \begin{macrocode}
\newcommand{\@FC@iflangloaded}[3]{%
  \ifcsundef{ver@fc-#1.def}{#3}{#2}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ProvidesFCLanguage}
%\changes{2.0}{2012/06/3}{new}
% Declare fmtcount language definition file. Adapted from
% \ics{ProvidesFile}.
%    \begin{macrocode}
\newcommand*{\ProvidesFCLanguage}[1]{%
  \ProvidesFile{fc-#1.def}%
}
%    \end{macrocode}
%\end{macro}
%
% We need that flag to remember that a language has been loaded via package option, so that in the end we can
% set \styfmt{fmtcount} in multiling
%    \begin{macrocode}
\newif\iffmtcount@language@option
\fmtcount@language@optionfalse
%    \end{macrocode}
%\begin{macro}{\fc@supported@language@list}
%    Declare list of supported languages, as a comma separated list. No space, no empty items. Each item is a
%    language for which fmtcount is able to load language specific definitions. \texttt{Aliases but be
%    \textit{after} their meaning, for instance `american' being an alias of `USenglish', it has to appear
%    after it in the list}. The raison d'\^etre of this list is to commonalize iteration on languages for the
%    two following purposes:
%    \begin{itemize}
%    \item loading language definition as a result of the language being used by
%      \styfmt{babel}/\styfmt{polyglossia}
%    \item loading language definition as a result of package option
%    \end{itemize}
%    These two purposes cannot be handled in the same pass, we need two different passes otherwise there would
%    be some corner cases when a package would be required --- as a result of loading language definition for
%    one language --- between a \cs{DeclareOption} and a \cs{ProcessOption} which is forbidden by \LaTeXe.
%\changes{3.00}{2014/07/3}{new}
%\changes{3.05}{2017/12/26}{Add brazilian and portuguese.}
%    \begin{macrocode}
\newcommand*\fc@supported@language@list{%
arabic,%
english,%
UKenglish,%
brazilian,%
british,%
USenglish,%
american,%
spanish,%
portuges,%
portuguese,%
french,%
frenchb,%
francais,%
german,%
germanb,%
ngerman,%
ngermanb,%
italian}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\fc@iterate@on@languages}
%\begin{definition}
%\cs{fc@iterate@on@languages}\marg{body}
%\end{definition}
% Now make some language iterator, note that for the following to work properly
% \cs{fc@supported@language@list} must not be empty. \meta{body} is  a macro that takes one argument, and
% \cs{fc@iterate@on@languages} applies it iteratively :
%\changes{3.00}{2014/07/03}{new}
%    \begin{macrocode}
\newcommand*\fc@iterate@on@languages[1]{%
  \ifx\fc@supported@language@list\@empty
%    \end{macrocode}
% That case should never happen !
%    \begin{macrocode}
    \PackageError{fmtcount}{Macro `\protect\@fc@iterate@on@languages' is empty}{You should never get here:
      Something is broken within \texttt{fmtcount}, please report the issue on
      \texttt{https://github.com/search?q=fmtcount\&ref=cmdform\&type=Issues}}%
  \else
    \let\fc@iterate@on@languages@body#1
    \expandafter\@fc@iterate@on@languages\fc@supported@language@list,\@nil,%
  \fi
}
\def\@fc@iterate@on@languages#1,{%
    {%
      \def\@tempa{#1}%
      \ifx\@tempa\@nnil
        \let\@tempa\@empty
      \else
        \def\@tempa{%
          \fc@iterate@on@languages@body{#1}%
          \@fc@iterate@on@languages
        }%
      \fi
      \expandafter
    }\@tempa
}%
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@fc@loadifbabelorpolyglossialdf}
%\begin{definition}
%\cs{@fc@loadifbabelorpolyglossialdf}\marg{language}
%\end{definition}
%Loads fmtcount language file,
%\texttt{fc-}\meta{language}\texttt{.def}, 
% if one of the following condition is met:
% \begin{itemize}
% \item \styfmt{babel} language definition file \meta{language}\texttt{.ldf} has been loaded --- conditionally
% to compilation with \texttt{latex}, not \texttt{xelatex}.
% \item \styfmt{polyglossia} language definition file \texttt{gloss-}\meta{language}\texttt{.ldf} has been
%   loaded --- conditionally to compilation with \texttt{xelatex}, not \texttt{latex}.
% \item \meta{language} option has been passed to package \styfmt{fmtcount}.
% \end{itemize}
% 
%\changes{2.03}{2012/11/03}{renamed \cs{@fc@loadifbabelldf} to
% \cs{@fc@loadifbabelorpolyglossialdf}}
%\changes{2.03}{2012/11/03}{added check for polyglossia language.}
%\changes{3.00}{2014/07/03}{use \cs{ifxetex} to discriminate between \styfmt{babel} and \styfmt{polyglossia}.}
%\changes{3.05}{2017/12/24}{Stop using \cs{ifxetex} to discriminate between \styfmt{babel} and
% \styfmt{polyglossia}, instead just test which package is loaded.}
%    \begin{macrocode}
\newcommand*\@fc@loadifbabelldf[1]{\ifcsundef{ver@#1.ldf}{}{\FCloadlang{#1}}}
\newcommand*{\@fc@loadifbabelorpolyglossialdf}[1]{}
\@ifpackageloaded{polyglossia}{%
  \def\@fc@loadifbabelorpolyglossialdf#1{\IfFileExists{gloss-#1.ldf}{\ifcsundef{#1@loaded}{}{\FCloadlang{#1}}}{}%
    \@fc@loadifbabelldf{#1}%
  }%
}{\@ifpackageloaded{babel}{%
  \let\@fc@loadifbabelorpolyglossialdf\@fc@loadifbabelldf
}{}}
%    \end{macrocode}
%\end{macro}
%
% Load appropriate language definition files:
%\changes{1.1}{2007/06/14}{added check for UKenglish,
% british and USenglish babel settings}
%\changes{2.0}{2012/06/03}{changed check for \cs{l@}\meta{language} 
% to check for \cs{date}\meta{language}}
%\changes{3.00}{2014/07/03}{use iterator rather than doing it flat on each language}
%\changes{3.01}{2014/12/03}{Define language aliases to \cs{fmtord}
%   option dependent on ``true'' language .}
%    \begin{macrocode}
\fc@iterate@on@languages\@fc@loadifbabelorpolyglossialdf
%    \end{macrocode}
% By default all languages are unique --- i.e. aliases not yet defined.
%    \begin{macrocode}
\def\fc@iterate@on@languages@body#1{%
  \expandafter\def\csname fc@#1@alias@of\endcsname{#1}}
\expandafter\@fc@iterate@on@languages\fc@supported@language@list,\@nil,%
%    \end{macrocode}
% Now define those languages that are aliases of another
% language. This is done with: \cs{@tempa}\marg{alias}\marg{language}
%    \begin{macrocode}
\def\@tempa#1#2{%
  \expandafter\def\csname fc@#1@alias@of\endcsname{#2}%
}%
\@tempa{frenchb}{french}
\@tempa{francais}{french}
\@tempa{germanb}{german}
\@tempa{ngermanb}{german}
\@tempa{ngerman}{german}
\@tempa{british}{english}
\@tempa{american}{USenglish}
%    \end{macrocode}
% Now, thanks to the aliases, we are going to define one option for each language, so that each language can
% have its own settings.
%    \begin{macrocode}
\def\fc@iterate@on@languages@body#1{%
  \define@key{fmtcount}{#1}[]{%
    \@FC@iflangloaded{#1}%
    {%
      \setkeys{fc\csname fc@#1@alias@of\endcsname}{##1}%
    }{%
      \PackageError{fmtcount}%
      {Language `#1' not defined}%
      {You need to load \ifxetex polyglossia\else babel\fi\space before loading fmtcount}%
    }%
  }%
  \ifthenelse{\equal{\csname fc@#1@alias@of\endcsname}{#1}}{%
    \define@key{fc\csname fc@#1@alias@of\endcsname}{fmtord}{%
      \ifthenelse{\equal{##1}{raise}\or\equal{##1}{level}}{%
        \expandafter\let\expandafter\@tempa\csname fc@set@ord@as@##1\endcsname
        \expandafter\@tempa\csname fc@ord@#1\endcsname
      }{%
        \ifthenelse{\equal{##1}{undefine}}{%
          \expandafter\let\csname fc@ord@#1\endcsname\undefined
        }{%
          \PackageError{fmtcount}%
          {Invalid value `##1' to fmtord key}%
          {Option `fmtord' can only take the values `level', `raise'
            or `undefine'}%
        }}
    }%
  }{%
%    \end{macrocode}
% When the language \texttt{\#1} is an alias, do the same as the language of which it is an alias:
%    \begin{macrocode}
    \expandafter\let\expandafter\@tempa\csname KV@\csname fc@#1@alias@of\endcsname @fmtord\endcsname
    \expandafter\let\csname KV@#1@fmtord\endcsname\@tempa
  }%
}
\expandafter\@fc@iterate@on@languages\fc@supported@language@list,\@nil,%
%    \end{macrocode}
%\begin{option}{fmtord}
% Key to determine how to display the ordinal
% \changes{3.01}{2014/12/03}{Apply option directly, rather than doing a border effect on \cs{fmtcount@fmtord},
% and then postprocessing depending on \cs{fmtcount@fmtord} at the end of \cs{fmtcountsetoptions}}
%    \begin{macrocode}
\def\fc@set@ord@as@level#1{%
  \def#1##1{##1}%
}
\def\fc@set@ord@as@raise#1{%
  \let#1\fc@textsuperscript
}
\define@key{fmtcount}{fmtord}{%
  \ifthenelse{\equal{#1}{level}
           \or\equal{#1}{raise}}%
  {%
    \csname fc@set@ord@as@#1\endcsname\fc@orddef@ult
    \def\fmtcount@fmtord{#1}%
  }%
  {%
    \PackageError{fmtcount}%
    {Invalid value `#1' to fmtord key}%
    {Option `fmtord' can only take the values `level' or `raise'}%
  }%
}
%    \end{macrocode}
%\end{option}
%\begin{macro}{\iffmtord@abbrv}
%  Key to determine whether the ordinal superscript should be
%  abbreviated (language dependent, currently only affects French
%  ordinals, non-abbreviated French ordinals ending --- i.e. `ier' and
%  `i\`eme' --- are considered faulty.)
%    \begin{macrocode}
\newif\iffmtord@abbrv
%    \end{macrocode}
% \changes{3.01}{2014/11/03}{Make `true' the default for option
% `abbrv', as in French this is the correct behaviour, and currently
% only French uses that}
%    \begin{macrocode}
\fmtord@abbrvtrue
\define@key{fmtcount}{abbrv}[true]{%
  \ifthenelse{\equal{#1}{true}\or\equal{#1}{false}}%
  {%
    \csname fmtord@abbrv#1\endcsname
  }%
  {%
    \PackageError{fmtcount}%
    {Invalid value `#1' to fmtord key}%
    {Option `abbrv' can only take the values `true' or
     `false'}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{option}{prefix}
%\changes{2.0}{2012/06/03}{new}
%    \begin{macrocode}
\define@key{fmtcount}{prefix}[scale=long]{%
  \RequirePackage{fmtprefix}%
  \fmtprefixsetoption{#1}%
}
%    \end{macrocode}
%\end{option}
%\begin{macro}{\fmtcountsetoptions}
% Define command to set options.
% \changes{3.01}{2014/12/03}{Move French specific stuff to \styfmt{french.def}.}
%    \begin{macrocode}
\def\fmtcountsetoptions{%
  \def\fmtcount@fmtord{}%
  \setkeys{fmtcount}}%
%    \end{macrocode}
%\end{macro}
% Load configuration file if it exists.  This needs to be done
% before the package options, to allow the user to override
% the settings in the configuration file.
%\changes{2.0}{2012/06/03}{Now no message if fmtcount.cfg not found}
%    \begin{macrocode}
\InputIfFileExists{fmtcount.cfg}%
{%
  \PackageInfo{fmtcount}{Using configuration file fmtcount.cfg}%
}%
{%
}
%    \end{macrocode}
%\begin{macro}{\fmtcount@loaded@by@option@lang@list}
% \changes{3.01}{2014/10/03}{Declare language option so that actual loading happens after \cs{ProcessOptions},
% and the \cs{ProcessOption} only registers the language for loading.}
%    \begin{macrocode}
\newcommand*{\fmtcount@loaded@by@option@lang@list}{}
%    \end{macrocode}
%\end{macro}
%\begin{option}{\meta{language}}
%Option \meta{language} causes language \meta{language} to be registered for loading. 
%    \begin{macrocode}
\newcommand*\@fc@declare@language@option[1]{%
  \DeclareOption{#1}{%
    \ifx\fmtcount@loaded@by@option@lang@list\@empty
       \def\fmtcount@loaded@by@option@lang@list{#1}%
    \else
       \edef\fmtcount@loaded@by@option@lang@list{\fmtcount@loaded@by@option@lang@list,#1}%
    \fi
  }}%
\fc@iterate@on@languages\@fc@declare@language@option
%    \end{macrocode}
%\end{option}
%
%\begin{option}{level}
%    \begin{macrocode}
\DeclareOption{level}{\def\fmtcount@fmtord{level}%
  \def\fc@orddef@ult#1{#1}}
%    \end{macrocode}
%\end{option}
%\begin{option}{raise}
%    \begin{macrocode}
\DeclareOption{raise}{\def\fmtcount@fmtord{raise}%
  \def\fc@orddef@ult#1{\fc@textsuperscript{#1}}}
%    \end{macrocode}
%\end{option}
% Process package options 
% \changes{3.00}{2014/07/03}{Add \cs{relax} after \cs{ProcessOptions} like shown in \texttt{clsguide.pdf}}
%    \begin{macrocode}
\ProcessOptions\relax
%    \end{macrocode}
% \changes{3.01}{2014/10/03}{Load languages that have been registered for loading by package option.}
% Now we do the loading of all languages that have been set by option to be loaded.
%    \begin{macrocode}
\ifx\fmtcount@loaded@by@option@lang@list\@empty\else
\def\fc@iterate@on@languages@body#1{%
    \@FC@iflangloaded{#1}{}{%
      \fmtcount@language@optiontrue
      \FCloadlang{#1}%
     }}
\expandafter\@fc@iterate@on@languages\fmtcount@loaded@by@option@lang@list,\@nil,%
\fi
%    \end{macrocode}
%\begin{macro}{\@FCmodulo}
%\begin{definition}
%\cs{@FCmodulo}\marg{count reg}\marg{n}
%\end{definition}
%\changes{2.04}{2014/06/03}{renamed \cs{@modulo} to \cs{@FCmodulo}}
% Sets the count register to be its value modulo \meta{n}. 
% This is used for the
% date, time, ordinal and numberstring commands. (The
% \styfmt{fmtcount} package was originally part of the 
% \sty{datetime} package.)
%    \begin{macrocode}
\newcount\@DT@modctr
\newcommand*{\@FCmodulo}[2]{%
  \@DT@modctr=#1\relax
  \divide \@DT@modctr by #2\relax
  \multiply \@DT@modctr by #2\relax
  \advance #1 by -\@DT@modctr
}
%    \end{macrocode}
%\end{macro}
% The following registers are needed by |\@ordinal| etc
%    \begin{macrocode}
\newcount\@ordinalctr
\newcount\@orgargctr
\newcount\@strctr
\newcount\@tmpstrctr
%    \end{macrocode}
%Define commands that display numbers in different bases.
% Define counters and conditionals needed.
%    \begin{macrocode}
\newif\if@DT@padzeroes
\newcount\@DT@loopN
\newcount\@DT@X
%    \end{macrocode}
%\begin{macro}{\binarynum}
% Converts a decimal number to binary, and display.
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%    \begin{macrocode}
\newrobustcmd*{\@binary}[1]{%
  \@DT@padzeroestrue
  \@DT@loopN=17\relax
  \@strctr=\@DT@loopN
  \whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by \@ne}%
  \@strctr=65536\relax
  \@DT@X=#1\relax
  \loop
    \@DT@modctr=\@DT@X
    \divide\@DT@modctr by \@strctr
    \ifthenelse{\boolean{@DT@padzeroes}
       \and \(\@DT@modctr=0\)
       \and \(\@DT@loopN>\c@padzeroesN\)}%
    {}%
    {\the\@DT@modctr}%
    \ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
    \multiply\@DT@modctr by \@strctr
    \advance\@DT@X by -\@DT@modctr
    \divide\@strctr by \tw@
    \advance\@DT@loopN by \m@ne
  \ifnum\@strctr>\@ne
  \repeat
  \the\@DT@X
}

\let\binarynum=\@binary
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\octalnum}
% Converts a decimal number to octal, and displays.
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%    \begin{macrocode}
\newrobustcmd*{\@octal}[1]{%
  \@DT@X=#1\relax
  \ifnum\@DT@X>32768
    \PackageError{fmtcount}%
    {Value of counter too large for \protect\@octal}
    {Maximum value 32768}
  \else
  \@DT@padzeroestrue
  \@DT@loopN=6\relax
  \@strctr=\@DT@loopN
  \whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by \@ne}%
  \@strctr=32768\relax
  \loop
    \@DT@modctr=\@DT@X
    \divide\@DT@modctr by \@strctr
    \ifthenelse{\boolean{@DT@padzeroes}
       \and \(\@DT@modctr=0\)
       \and \(\@DT@loopN>\c@padzeroesN\)}%
    {}{\the\@DT@modctr}%
    \ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
    \multiply\@DT@modctr by \@strctr
    \advance\@DT@X by -\@DT@modctr
    \divide\@strctr by \@viiipt
    \advance\@DT@loopN by \m@ne
  \ifnum\@strctr>\@ne
  \repeat
  \the\@DT@X
  \fi
}
\let\octalnum=\@octal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@@hexadecimal}
% Converts number from 0 to 15 into lowercase hexadecimal notation.
%    \begin{macrocode}
\newcommand*{\@@hexadecimal}[1]{%
  \ifcase#10\or1\or2\or3\or4\or5\or
  6\or7\or8\or9\or a\or b\or c\or d\or e\or f\fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\hexadecimalnum}
% Converts a decimal number to a lowercase hexadecimal number, 
% and displays it.
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%\changes{3.06}{2018/06/27}{Rename \cs{Hexadecimalnum} to \cs{HEXADecimalnum} and \cs{Hexadecimal} to
%    \cs{HEXADecimal} and factorize the code between \cs{HEXADecimalnum} and \cs{hexadecimalnum}.}
%    \begin{macrocode}
\newrobustcmd*{\hexadecimalnum}{\@hexadecimalengine\@@hexadecimal}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@@Hexadecimal}
% Converts number from 0 to 15 into uppercase hexadecimal notation.
%    \begin{macrocode}
\newcommand*{\@@Hexadecimal}[1]{%
  \ifcase#10\or1\or2\or3\or4\or5\or6\or
  7\or8\or9\or A\or B\or C\or D\or E\or F\fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\HEXADecimalnum}
% Uppercase hexadecimal
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%\changes{3.06}{2018/06/27}{Rename \cs{Hexadecimalnum} to \cs{HEXADecimalnum} and \cs{Hexadecimal} to
%    \cs{HEXADecimal} and factorize the code between \cs{HEXADecimalnum} and \cs{hexadecimalnum}.}
%    \begin{macrocode}
\newrobustcmd*{\HEXADecimalnum}{\@hexadecimalengine\@@Hexadecimal}
\newcommand*{\@hexadecimalengine}[2]{%
  \@DT@padzeroestrue
  \@DT@loopN=\@vpt
  \@strctr=\@DT@loopN
  \whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by \@ne}%
  \@strctr=65536\relax
  \@DT@X=#2\relax
  \loop
    \@DT@modctr=\@DT@X
    \divide\@DT@modctr by \@strctr
    \ifthenelse{\boolean{@DT@padzeroes}
      \and \(\@DT@modctr=0\)
      \and \(\@DT@loopN>\c@padzeroesN\)}
    {}{#1\@DT@modctr}%
    \ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
    \multiply\@DT@modctr by \@strctr
    \advance\@DT@X by -\@DT@modctr
    \divide\@strctr by 16\relax
    \advance\@DT@loopN by \m@ne
  \ifnum\@strctr>\@ne
  \repeat
  #1\@DT@X
}
\def\Hexadecimalnum{%
  \PackageWarning{fmtcount}{\string\Hexadecimalnum\space is deprecated, use \string\HEXADecimalnum\space
    instead. The \string\Hexadecimalnum\space control sequence name is confusing as it can mislead in thinking
    that only the 1st letter is upper-cased.}%
  \HEXADecimalnum}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\aaalphnum}
% Lowercase alphabetical representation (a \ldots\ z aa \ldots\ zz)
% \changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
% \changes{3.04}{2017/09/16}{Code optimization, use of \cs{@ne} and \cs{m@ne}, and assign \texttt{\#1} only
% once. Factorize code with \cs{@AAAlph}.}
%    \begin{macrocode}
\newrobustcmd*{\@aaalph}{\fc@aaalph\@alph}
\newcommand*\fc@aaalph[2]{%
  \@DT@loopN=#2\relax
  \@DT@X\@DT@loopN
  \advance\@DT@loopN by \m@ne
  \divide\@DT@loopN by 26\relax
  \@DT@modctr=\@DT@loopN
  \multiply\@DT@modctr by 26\relax
  \advance\@DT@X by \m@ne
  \advance\@DT@X by -\@DT@modctr
  \advance\@DT@loopN by \@ne
  \advance\@DT@X by \@ne
  \edef\@tempa{#1\@DT@X}%
  \loop
    \@tempa
    \advance\@DT@loopN by \m@ne
  \ifnum\@DT@loopN>0
  \repeat
}

\let\aaalphnum=\@aaalph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\AAAlphnum}
% Uppercase alphabetical representation (a \ldots\ z aa \ldots\ zz)
% \changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
% \changes{3.04}{2017/09/16}{Code optimization, factorize code with \@aaalph.}
%    \begin{macrocode}
\newrobustcmd*{\@AAAlph}{\fc@aaalph\@Alph}%

\let\AAAlphnum=\@AAAlph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\abalphnum}
% Lowercase alphabetical representation
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
% \changes{3.04}{2017/09/16}{Code factorization with \cs{@ABAlph}. Code optimization, assign \texttt{\#1} only
% once. Use \cs{@ne} and \cs{m@ne}.}
%    \begin{macrocode}
\newrobustcmd*{\@abalph}{\fc@abalph\@alph}%
\newcommand*\fc@abalph[2]{%
  \@DT@X=#2\relax
  \ifnum\@DT@X>17576\relax
    \ifx#1\@alph\def\@tempa{\@abalph}%
    \else\def\@tempa{\@ABAlph}\fi
    \PackageError{fmtcount}%
    {Value of counter too large for \expandafter\protect\@tempa}%
    {Maximum value 17576}%
  \else
    \@DT@padzeroestrue
    \@strctr=17576\relax
    \advance\@DT@X by \m@ne
    \loop
      \@DT@modctr=\@DT@X
      \divide\@DT@modctr by \@strctr
      \ifthenelse{\boolean{@DT@padzeroes}
        \and \(\@DT@modctr=1\)}%
      {}{#1\@DT@modctr}%
      \ifnum\@DT@modctr=\@ne\else\@DT@padzeroesfalse\fi
      \multiply\@DT@modctr by \@strctr
      \advance\@DT@X by -\@DT@modctr
      \divide\@strctr by 26\relax
    \ifnum\@strctr>\@ne
    \repeat
    \advance\@DT@X by \@ne
    #1\@DT@X
  \fi
}

\let\abalphnum=\@abalph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ABAlphnum}
% Uppercase alphabetical representation
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%\changes{3.04}{2017/09/16}{Code optimization, factorize code with \cs{@abalph}.}
%    \begin{macrocode}
\newrobustcmd*{\@ABAlph}{\fc@abalph\@Alph}%
\let\ABAlphnum=\@ABAlph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@fmtc@count}
% Recursive command to count number of characters in argument.
% \cs{@strctr} should be set to zero before calling it.
%    \begin{macrocode}
\def\@fmtc@count#1#2\relax{%
  \if\relax#1%
  \else
    \advance\@strctr by 1\relax
    \@fmtc@count#2\relax
  \fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@decimal}
%\changes{1.31}{2009/10/02}{fixed unwanted space.}
% Format number as a decimal, possibly padded with zeroes in front.
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%    \begin{macrocode}
\newrobustcmd*{\@decimal}[1]{%
  \@strctr=0\relax
  \expandafter\@fmtc@count\number#1\relax
  \@DT@loopN=\c@padzeroesN
  \advance\@DT@loopN by -\@strctr
  \ifnum\@DT@loopN>0\relax
    \@strctr=0\relax
    \whiledo{\@strctr < \@DT@loopN}{0\advance\@strctr by 1\relax}%
  \fi
  \number#1\relax
}

\let\decimalnum=\@decimal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\FCordinal}
%\begin{definition}
%\cs{FCordinal}\marg{number}
%\end{definition}
% This is a bit cumbersome.  Previously \cs{@ordinal}
% was defined in a similar way to \cs{abalph} etc.
% This ensured that the actual value of the counter was
% written in the new label stuff in the .aux file. However
% adding in an optional argument to determine the gender
% for multilingual compatibility messed things up somewhat.
% This was the only work around I could get to keep the
% the cross-referencing stuff working, which is why
% the optional argument comes \emph{after} the compulsory
% argument, instead of the usual manner of placing it before.
% Note however, that putting the optional argument means that
% any spaces will be ignored after the command if the optional
% argument is omitted.
% Version 1.04 changed \cs{ordinal} to \cs{FCordinal}
% to prevent it clashing with the memoir class. 
% \changes{3.02}{2015/08/01}{Suppress useless \cs{expandafter}'s and and use \cs{value} instead tweaking with
% \cs{csname}. Do not use any longer \cs{protect} as \cs{ordinalnum} is made robust.}
%    \begin{macrocode}
\newcommand{\FCordinal}[1]{%
  \ordinalnum{%
    \the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinal}
% If \cs{ordinal} isn't defined make \cs{ordinal} a synonym
% for \cs{FCordinal} to maintain compatibility with previous
% versions.
% \changes{3.00}{2014/07/03}{Use \cs{protect}, not \cs{string} in \cs{PackageWarning} to quote macros like
% shown in \texttt{clsguide.pdf}}
%    \begin{macrocode}
\ifcsundef{ordinal}
 {\let\ordinal\FCordinal}%
 {%
   \PackageWarning{fmtcount}%
   {\protect\ordinal \space already defined use 
    \protect\FCordinal \space instead.}
 }
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinalnum}
% Display ordinal where value is given as a number or 
% count register instead of a counter:
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
% \changes{3.02}{2015/08/03}{Make \cs{ordinalnum} robust.}
% \changes{3.04}{2017/09/03}{Use \texttt{etoobox}'s \cs{newrobustcmd*} instead of \LaTeX\ kernel
% \cs{DeclareRobustcommand*} in order to make \cs{ordinalnum} robust. This is preferable, e.g. w.r.t. \TeX 4ht
% compilation.}
%    \begin{macrocode}
\newrobustcmd*{\ordinalnum}[1]{%
  \new@ifnextchar[%
  {\@ordinalnum{#1}}%
  {\@ordinalnum{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@ordinalnum}
% Display ordinal according to gender (neuter added in v1.1,
% \cs{xspace} added in v1.2, and removed in v1.3\footnote{I
%couldn't get it to work consistently both with and without the
%optional argument}):
%    \begin{macrocode}
\def\@ordinalnum#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@ordinalF{#1}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@ordinalN{#1}{\@fc@ordstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
           {Invalid gender option `#2'}%
           {Available options are m, f or n}%
        }%
        \protect\@ordinalM{#1}{\@fc@ordstr}%
      }%
    }%
    \@fc@ordstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinal}
% Store the ordinal (first argument
% is identifying name, second argument is a counter.)
% \changes{3.02}{2015/08/03}{Suppress useless \cs{expandafter}'s and and use \cs{value} instead tweaking with
% \cs{csname}. Do not use any longer \cs{protect} as \cs{storeordinalnum} is made robust.}
% \changes{3.02}{2016/01/08}{Expand \cs{the}\cs{value}\texttt{\{\#2\}} once before passing to \cs{storeordinalnum}}
%    \begin{macrocode}
\newcommand*{\storeordinal}[2]{%
  {%
    \toks0{\storeordinalnum{#1}}%
    \expandafter
   }\the\toks0\expandafter{%
    \the\value{#2}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinalnum}
% Store ordinal (first argument
% is identifying name, second argument is a number or
% count register.)
% \changes{3.02}{2016/01/08}{Make \cs{storeordinalnum} robust with etoolbox \cs{newrobustcmd}.}
%    \begin{macrocode}
\newrobustcmd*{\storeordinalnum}[2]{%
  \@ifnextchar[%
  {\@storeordinalnum{#1}{#2}}%
  {\@storeordinalnum{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@storeordinalnum}
% Store ordinal according to gender:
%    \begin{macrocode}
\def\@storeordinalnum#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@ordinalF{#2}{\@fc@ord}
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@ordinalN{#2}{\@fc@ord}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m or f}%
      }%
      \protect\@ordinalM{#2}{\@fc@ord}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@ord
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\FMCuse}
% Get stored information:
%    \begin{macrocode}
\newcommand*{\FMCuse}[1]{\csname @fcs@#1\endcsname}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinalstring}
%  Display ordinal as a string (argument is a counter)
%  \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
%  and use \cs{value} instead tweaking with \cs{csname}. Do not use
%  any longer \cs{protect} as \cs{ordinalstringnum} is made
%  robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
%  passing to \cs{ordinalstringnum}}%
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{ordinalstringnum} is
% supposed to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for
% compatibily with \texttt{glossaries}.}
%    \begin{macrocode}
\newcommand*{\ordinalstring}[1]{%
  \ordinalstringnum{\expandafter\expandafter\expandafter
    \the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinalstringnum}
% Display ordinal as a string (argument is a count register or
% number.)
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%\changes{1.33}{2009/10/15}{Made robust}
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%    \begin{macrocode}
\newrobustcmd*{\ordinalstringnum}[1]{%
  \new@ifnextchar[%
  {\@ordinal@string{#1}}%
  {\@ordinal@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@ordinal@string}
% Display ordinal as a string according to gender.
% \changes{3.00}{2014/07/03}{Use \cs{protect}, not \cs{string} in \cs{PackageError} to quote macros like
% shown in \texttt{clsguide.pdf}}
% \changes{3.00}{2014/07/03}{Correct detailed error message, so `n' is one of available gender options}
%    \begin{macrocode}
\def\@ordinal@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@ordinalstringF{#1}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@ordinalstringN{#1}{\@fc@ordstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2' to \protect\ordinalstring}%
          {Available options are m, f or n}%
        }%
        \protect\@ordinalstringM{#1}{\@fc@ordstr}%
      }%
    }%
    \@fc@ordstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinalstring}
% Store textual representation of number. First argument is 
% identifying name, second argument is the counter set to the 
% required number.
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{storeordinalstringnum} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#2\}} once before
% passing to \cs{storeordinalstringnum}}
%    \begin{macrocode}
\newcommand*{\storeordinalstring}[2]{%
  {%
    \toks0{\storeordinalstringnum{#1}}%
    \expandafter
  }\the\toks0\expandafter{\the\value{#2}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinalstringnum}
% Store textual representation of number. First argument is 
% identifying name, second argument is a count register or number.
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%    \begin{macrocode}
\newrobustcmd*{\storeordinalstringnum}[2]{%
  \@ifnextchar[%
  {\@store@ordinal@string{#1}{#2}}%
  {\@store@ordinal@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@ordinal@string}
% Store textual representation of number according to gender.
% \changes{3.00}{2014/07/03}{Use \cs{protect}, not \cs{string} in \cs{PackageWarning} to quote macros like
% shown in \texttt{clsguide.pdf}}
%    \begin{macrocode}
\def\@store@ordinal@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@ordinalstringF{#2}{\@fc@ordstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@ordinalstringN{#2}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3' to \protect\ordinalstring}%
        {Available options are m, f or n}%
      }%
      \protect\@ordinalstringM{#2}{\@fc@ordstr}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@ordstr
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Ordinalstring}
% Display ordinal as a string with initial letters in upper case
% (argument is a counter)
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{Ordinalstringnum} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{Ordinalstringnum}}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{Ordinalstringnum} is
% supposed to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for
% compatibily with \texttt{glossaries}.}
%    \begin{macrocode}
\newcommand*{\Ordinalstring}[1]{%
  \Ordinalstringnum{\expandafter\expandafter\expandafter\the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Ordinalstringnum}
% Display ordinal as a string with initial letters in upper case
% (argument is a number or count register)
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%    \begin{macrocode}
\newrobustcmd*{\Ordinalstringnum}[1]{%
  \new@ifnextchar[%
  {\@Ordinal@string{#1}}%
  {\@Ordinal@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@Ordinal@string}
% Display ordinal as a string with initial letters in upper case
% according to gender
%    \begin{macrocode}
\def\@Ordinal@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@OrdinalstringF{#1}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@OrdinalstringN{#1}{\@fc@ordstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@OrdinalstringM{#1}{\@fc@ordstr}%
      }%
    }%
    \@fc@ordstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeOrdinalstring}
% Store textual representation of number, with initial letters in 
% upper case. First argument is identifying name, second argument 
% is the counter set to the 
% required number.
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{storeOrdinalstringnum} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{storeOrdinalstringnum}}
%    \begin{macrocode}
\newcommand*{\storeOrdinalstring}[2]{%
  {%
    \toks0{\storeOrdinalstringnum{#1}}%
    \expandafter
  }\the\toks0\expandafter{\the\value{#2}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeOrdinalstringnum}
% Store textual representation of number, with initial letters in 
% upper case. First argument is identifying name, second argument 
% is a count register or number.
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%    \begin{macrocode}
\newrobustcmd*{\storeOrdinalstringnum}[2]{%
  \@ifnextchar[%
  {\@store@Ordinal@string{#1}{#2}}%
  {\@store@Ordinal@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@Ordinal@string}
% Store textual representation of number according to gender, 
% with initial letters in upper case.
%    \begin{macrocode}
\def\@store@Ordinal@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@OrdinalstringF{#2}{\@fc@ordstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@OrdinalstringN{#2}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m or f}%
      }%
      \protect\@OrdinalstringM{#2}{\@fc@ordstr}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@ordstr
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\storeORDINALstring}
% Store upper case textual representation of ordinal. The first 
% argument is identifying name, the second argument is a counter.
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{storeORDINALstringnum} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#2\}} once before
% passing to \cs{storeORDINALstringnum}.}
%    \begin{macrocode}
\newcommand*{\storeORDINALstring}[2]{%
  {%
    \toks0{\storeORDINALstringnum{#1}}%
    \expandafter
  }\the\toks0\expandafter{\the\value{#2}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeORDINALstringnum}
% As above, but the second argument is a count register or a
% number.
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%    \begin{macrocode}
\newrobustcmd*{\storeORDINALstringnum}[2]{%
  \@ifnextchar[%
  {\@store@ORDINAL@string{#1}{#2}}%
  {\@store@ORDINAL@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@ORDINAL@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@store@ORDINAL@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@ordinalstringF{#2}{\@fc@ordstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@ordinalstringN{#2}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m or f}%
      }%
      \protect\@ordinalstringM{#2}{\@fc@ordstr}%
    }%
  }%
%    \end{macrocode}
% \changes{3.01}{2014/11/03}{Protect \cs{`}.}
%    \begin{macrocode}
  \expandafter\protected@edef\csname @fcs@#1\endcsname{%
    \noexpand\MakeUppercase{\@fc@ordstr}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ORDINALstring}
% Display upper case textual representation of an ordinal. The
% argument must be a counter.
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{ORDINALstringnum} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{ORDINALstringnum}}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{ORDINALstringnum} is
% supposed to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for
% compatibily with \texttt{glossaries}.}
%    \begin{macrocode}
\newcommand*{\ORDINALstring}[1]{%
  \ORDINALstringnum{\expandafter\expandafter\expandafter
    \the\value{#1}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ORDINALstringnum}
% As above, but the argument is a count register or a number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%    \begin{macrocode}
\newrobustcmd*{\ORDINALstringnum}[1]{%
  \new@ifnextchar[%
  {\@ORDINAL@string{#1}}%
  {\@ORDINAL@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@ORDINAL@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@ORDINAL@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@ordinalstringF{#1}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@ordinalstringN{#1}{\@fc@ordstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@ordinalstringM{#1}{\@fc@ordstr}%
      }%
    }%
    \MakeUppercase{\@fc@ordstr}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storenumberstring}
% Convert number to textual respresentation, and store. First 
% argument is the identifying name, second argument is a counter 
% containing the number.
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{storenumberstringnum} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#2\}} once before
% passing to \cs{storenumberstringnum}}
%    \begin{macrocode}
\newcommand*{\storenumberstring}[2]{%
  \expandafter\protect\expandafter\storenumberstringnum{#1}{%
    \expandafter\the\value{#2}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storenumberstringnum}
% As above, but second argument is a number or count register.
%    \begin{macrocode}
\newcommand{\storenumberstringnum}[2]{%
  \@ifnextchar[%
  {\@store@number@string{#1}{#2}}%
  {\@store@number@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@number@string}
% Gender is given as optional argument, \emph{at the end}.
%    \begin{macrocode}
\def\@store@number@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@numberstringF{#2}{\@fc@numstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@numberstringN{#2}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}
        {Invalid gender option `#3'}%
        {Available options are m, f or n}%
      }%
      \protect\@numberstringM{#2}{\@fc@numstr}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@numstr
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\numberstring}
% Display textual representation of a number. The argument
% must be a counter.
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{numberstringnum} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{numberstringnum}}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{numberstringnum} is
% supposed to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for
% compatibily with \texttt{glossaries}.}
%    \begin{macrocode}
\newcommand*{\numberstring}[1]{%
  \numberstringnum{\expandafter\expandafter\expandafter
    \the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\numberstringnum}
% As above, but the argument is a count register or a number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%    \begin{macrocode}
\newrobustcmd*{\numberstringnum}[1]{%
  \new@ifnextchar[%
  {\@number@string{#1}}%
  {\@number@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\@number@string}
% Gender is specified as an optional argument \emph{at the end}.
%    \begin{macrocode}
\def\@number@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@numberstringF{#1}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
         \protect\@numberstringN{#1}{\@fc@numstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@numberstringM{#1}{\@fc@numstr}%
      }%
    }%
    \@fc@numstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNumberstring}
% Store textual representation of number. First argument is 
% identifying name, second argument is a counter.
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{storeNumberstringnum} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#2\}} once before
% passing to \cs{storeNumberstringnum}}
%    \begin{macrocode}
\newcommand*{\storeNumberstring}[2]{%
  {%
    \toks0{\storeNumberstringnum{#1}}%
    \expandafter
  }\the\toks0\expandafter{\the\value{#2}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNumberstringnum}
% As above, but second argument is a count register or number.
%    \begin{macrocode}
\newcommand{\storeNumberstringnum}[2]{%
  \@ifnextchar[%
  {\@store@Number@string{#1}{#2}}%
  {\@store@Number@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@Number@string}
% Gender is specified as an optional argument \emph{at the end}:
%    \begin{macrocode}
\def\@store@Number@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@NumberstringF{#2}{\@fc@numstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@NumberstringN{#2}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m, f or n}%
      }%
      \protect\@NumberstringM{#2}{\@fc@numstr}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@numstr
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Numberstring}
% Display textual representation of number. The argument must be
% a counter. 
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{Numberstringnum} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{Numberstringnum}}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{Numberstringnum} is
% supposed to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for
% compatibily with \texttt{glossaries}.}
%    \begin{macrocode}
\newcommand*{\Numberstring}[1]{%
  \Numberstringnum{\expandafter\expandafter\expandafter
    \the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Numberstringnum}
% As above, but the argument is a count register or number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%    \begin{macrocode}
\newrobustcmd*{\Numberstringnum}[1]{%
  \new@ifnextchar[%
  {\@Number@string{#1}}%
  {\@Number@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@Number@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@Number@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@NumberstringF{#1}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@NumberstringN{#1}{\@fc@numstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@NumberstringM{#1}{\@fc@numstr}%
      }%
    }%
    \@fc@numstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNUMBERstring}
% Store upper case textual representation of number. The first 
% argument is identifying name, the second argument is a counter.
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{storeNUMBERstringnum} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#2\}} once before
% passing to \cs{storeNUMBERstringnum}.}
%    \begin{macrocode}
\newcommand{\storeNUMBERstring}[2]{%
  {%
    \toks0{\storeNUMBERstringnum{#1}}%
    \expandafter
    }\the\toks0\expandafter{\the\value{#2}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNUMBERstringnum}
% As above, but the second argument is a count register or a
% number.
%    \begin{macrocode}
\newcommand{\storeNUMBERstringnum}[2]{%
  \@ifnextchar[%
  {\@store@NUMBER@string{#1}{#2}}%
  {\@store@NUMBER@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@NUMBER@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@store@NUMBER@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@numberstringF{#2}{\@fc@numstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@numberstringN{#2}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m or f}%
      }%
      \protect\@numberstringM{#2}{\@fc@numstr}%
    }%
  }%
  \expandafter\edef\csname @fcs@#1\endcsname{%
    \noexpand\MakeUppercase{\@fc@numstr}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\NUMBERstring}
% Display upper case textual representation of a number. The
% argument must be a counter.
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{NUMBERstringnum} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{NUMBERstringnum}.}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{NUMBERstringnum} is
% supposed to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for
% compatibily with \texttt{glossaries}.}
%    \begin{macrocode}
\newcommand*{\NUMBERstring}[1]{%
  \NUMBERstringnum{\expandafter\expandafter\expandafter
    \the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\NUMBERstringnum}
% As above, but the argument is a count register or a number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%\changes{3.02}{2016/01/08}{Made robust using \texttt{etoolbox} \cs{newrobustcmd}}
%    \begin{macrocode}
\newrobustcmd*{\NUMBERstringnum}[1]{%
  \new@ifnextchar[%
  {\@NUMBER@string{#1}}%
  {\@NUMBER@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@NUMBER@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@NUMBER@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@numberstringF{#1}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
         \protect\@numberstringN{#1}{\@fc@numstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@numberstringM{#1}{\@fc@numstr}%
      }%
    }%
    \protect\MakeUppercase{\@fc@numstr}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\binary}
% Number representations in other bases. Binary:
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{@binary} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{@binary}}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{@binary} is supposed
% to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for compatibily with
% \texttt{glossaries}.}
%    \begin{macrocode}
\providecommand*{\binary}[1]{%
  \@binary{\expandafter\expandafter\expandafter
    \the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\aaalph}
% Like \ics{alph}, but goes beyond 26.
% (a \ldots\ z aa \ldots zz \ldots)
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{@aaalph} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{@aaalph}.}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{@aaalph} is supposed
% to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for compatibily with
% \texttt{glossaries}.}
%    \begin{macrocode}
\providecommand*{\aaalph}[1]{%
  \@aaalph{\expandafter\expandafter\expandafter
    \the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\AAAlph}
% As before, but upper case.
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{@AAAlph} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{@AAAlph}.}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{@AAAlph} is supposed
% to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for compatibily with
% \texttt{glossaries}.}
%    \begin{macrocode}
\providecommand*{\AAAlph}[1]{%
  \@AAAlph{\expandafter\expandafter\expandafter
    \the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\abalph}
% Like \ics{alph}, but goes beyond 26. 
% (a \ldots\ z ab \ldots az \ldots)
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{@abalph} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{@abalph}.}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{@abalph} is supposed
% to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for compatibily with
% \texttt{glossaries}.}
%    \begin{macrocode}
\providecommand*{\abalph}[1]{%
  \@abalph{\expandafter\expandafter\expandafter
    \the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ABAlph}
% As above, but upper case.
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{@ABAlph} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{@ABAlph}.}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{@ABAlph} is supposed
% to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for compatibily with
% \texttt{glossaries}.}
%    \begin{macrocode}
\providecommand*{\ABAlph}[1]{%
  \@ABAlph{\expandafter\expandafter\expandafter
    \the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\hexadecimal}
% Hexadecimal:
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{@hexadecimal} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{@hexadecimal}.}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{@hexadecimal} is
% supposed to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for
% compatibily with \texttt{glossaries}.}
%    \begin{macrocode}
\providecommand*{\hexadecimal}[1]{%
  \hexadecimalnum{\expandafter\expandafter\expandafter
    \the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\HEXADecimal}
% As above, but in upper case.
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{@Hexadecimal} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{@Hexadecimal}.}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{@Hexadecimal} is
% supposed to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for
% compatibily with \texttt{glossaries}.}
%    \begin{macrocode}
\providecommand*{\HEXADecimal}[1]{%
  \HEXADecimalnum{\expandafter\expandafter\expandafter
    \the\value{#1}}%
}
\newrobustcmd*\FC@Hexadecimal@warning{%
  \PackageWarning{fmtcount}{\string\Hexadecimal\space is deprecated, use \string\HEXADecimal\space
    instead. The \string\Hexadecimal\space control sequence name is confusing as it can mislead in thinking
    that only the 1st letter is upper-cased.}%
}
\def\Hexadecimal{%
  \FC@Hexadecimal@warning
  \HEXADecimal}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\octal}
% Octal:
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{@octal} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{@octal}}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{@octal} is supposed
% to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for compatibily with
% \texttt{glossaries}.}
%    \begin{macrocode}
\providecommand*{\octal}[1]{%
  \@octal{\expandafter\expandafter\expandafter
    \the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\decimal}
% Decimal:
% \changes{3.02}{2016/01/08}{Suppress useless \cs{expandafter}'s and
% and use \cs{value} instead tweaking with \cs{csname}. Do not use any
% longer \cs{protect} as \cs{@decimal} is made
% robust. Expand \cs{the}\cs{value}\texttt{\{\#1\}} once before
% passing to \cs{@decimal}}
% \changes{3.03}{2017/09/14}{Suppress leading \cs{expandafter}'s, they are useless as \cs{@decimal} is supposed
% to fully expand its argument, and place 3 \cs{expandafter}'s before \cs{the}\cs{value} for compatibily with
% \texttt{glossaries}.}
%    \begin{macrocode}
\providecommand*{\decimal}[1]{%
  \@decimal{\expandafter\expandafter\expandafter
    \the\value{#1}}%
}
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Multilinguage Definitions}
% Flag \cs{fc@languagemode@detected} allows to stop scanning for multilingual mode trigger conditions. It is
% initialized to \texttt{false} as no such scanning as taken place yet.
%\changes{3.05}{2017/12/22}{New flag \cs{iffc@languagemode@detected}.}
%    \begin{macrocode}
\newif\iffc@languagemode@detected
\fc@languagemode@detectedfalse
%    \end{macrocode}
%\begin{macro}{\@setdef@ultfmtcount}
% If multilingual support is provided, make \cs{@numberstring}
% etc use the correct language (if defined).
% Otherwise use English definitions. \cs{@setdef@ultfmtcount}
% sets the macros to use English.
%\changes{3.05}{2017/12/22}{Set flag \cs{iffc@languagemode@detected}.}
%    \begin{macrocode}
\def\@setdef@ultfmtcount{%
  \fc@languagemode@detectedtrue
  \ifcsundef{@ordinalMenglish}{\FCloadlang{english}}{}%
  \def\@ordinalstringM{\@ordinalstringMenglish}%
  \let\@ordinalstringF=\@ordinalstringMenglish
  \let\@ordinalstringN=\@ordinalstringMenglish
  \def\@OrdinalstringM{\@OrdinalstringMenglish}%
  \let\@OrdinalstringF=\@OrdinalstringMenglish
  \let\@OrdinalstringN=\@OrdinalstringMenglish
  \def\@numberstringM{\@numberstringMenglish}%
  \let\@numberstringF=\@numberstringMenglish
  \let\@numberstringN=\@numberstringMenglish
  \def\@NumberstringM{\@NumberstringMenglish}%
  \let\@NumberstringF=\@NumberstringMenglish
  \let\@NumberstringN=\@NumberstringMenglish
  \def\@ordinalM{\@ordinalMenglish}%
  \let\@ordinalF=\@ordinalM
  \let\@ordinalN=\@ordinalM
  \let\fmtord\fc@orddef@ult
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\fc@multiling}
%\changes{2.02}{2012/10/03}{new}
%\cs{fc@multiling}\marg{name}\marg{gender}
%\changes{3.00}{2014/07/03}{Use \cs{protect}, not \cs{string} in \cs{PackageWarning} to quote macros like
% shown in \texttt{clsguide.pdf}}
%    \begin{macrocode}
\newcommand*{\fc@multiling}[2]{%
  \ifcsundef{@#1#2\languagename}%
  {% try loading it
     \FCloadlang{\languagename}%
  }%
  {%
  }%
  \ifcsundef{@#1#2\languagename}%
  {%
    \PackageWarning{fmtcount}%
    {No support for \expandafter\protect\csname #1\endcsname\space for
     language '\languagename'}%
    \ifthenelse{\equal{\languagename}{\fc@mainlang}}%
    {%
       \FCloadlang{english}%
    }%
    {%
    }%
    \ifcsdef{@#1#2\fc@mainlang}%
    {%
       \csuse{@#1#2\fc@mainlang}%
    }%
    {%
       \PackageWarningNoLine{fmtcount}%
       {No languages loaded at all! Loading english definitions}%
       \FCloadlang{english}%
       \def\fc@mainlang{english}%
       \csuse{@#1#2english}%
    }%
  }%
  {%
    \csuse{@#1#2\languagename}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@set@mulitling@fmtcount}
% This defines the number and ordinal string macros to use 
% \cs{languagename}:
%\changes{2.0}{2012/06/03}{changed errors to warnings for
%unsupported languages}
%\changes{3.05}{2017/12/22}{Set flag \cs{iffc@languagemode@detected}.}
%    \begin{macrocode}
\def\@set@mulitling@fmtcount{%
  \fc@languagemode@detectedtrue
%    \end{macrocode}
% The masculine version of \cs{numberstring}:
%    \begin{macrocode}
  \def\@numberstringM{%
    \fc@multiling{numberstring}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{numberstring}:
%    \begin{macrocode}
  \def\@numberstringF{%
    \fc@multiling{numberstring}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{numberstring}:
%    \begin{macrocode}
  \def\@numberstringN{%
    \fc@multiling{numberstring}{N}%
  }%
%    \end{macrocode}
% The masculine version of \cs{Numberstring}:
%    \begin{macrocode}
  \def\@NumberstringM{%
    \fc@multiling{Numberstring}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{Numberstring}:
%    \begin{macrocode}
  \def\@NumberstringF{%
    \fc@multiling{Numberstring}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{Numberstring}:
%    \begin{macrocode}
  \def\@NumberstringN{%
    \fc@multiling{Numberstring}{N}%
  }%
%    \end{macrocode}
% The masculine version of \cs{ordinal}:
%    \begin{macrocode}
  \def\@ordinalM{%
    \fc@multiling{ordinal}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{ordinal}:
%    \begin{macrocode}
  \def\@ordinalF{%
    \fc@multiling{ordinal}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{ordinal}:
%    \begin{macrocode}
  \def\@ordinalN{%
    \fc@multiling{ordinal}{N}%
  }%
%    \end{macrocode}
% The masculine version of \cs{ordinalstring}:
%    \begin{macrocode}
  \def\@ordinalstringM{%
    \fc@multiling{ordinalstring}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{ordinalstring}:
%    \begin{macrocode}
  \def\@ordinalstringF{%
    \fc@multiling{ordinalstring}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{ordinalstring}:
%    \begin{macrocode}
  \def\@ordinalstringN{%
    \fc@multiling{ordinalstring}{N}%
  }%
%    \end{macrocode}
% The masculine version of \cs{Ordinalstring}:
%    \begin{macrocode}
  \def\@OrdinalstringM{%
    \fc@multiling{Ordinalstring}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{Ordinalstring}:
%    \begin{macrocode}
  \def\@OrdinalstringF{%
    \fc@multiling{Ordinalstring}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{Ordinalstring}:
%    \begin{macrocode}
  \def\@OrdinalstringN{%
    \fc@multiling{Ordinalstring}{N}%
  }%
%    \end{macrocode}
% Make \cs{fmtord} language dependent:
% \changes{3.01}{2014/12/03}{Make \cs{fmtord} language dependent.}
%    \begin{macrocode}
  \let\fmtord\fc@ord@multiling
}
%    \end{macrocode}
%\end{macro}
%\changes{3.05}{2017/12/22}{Change all the code about detecting multiling. \cs{ifxetex} is no longer used,
% instead we loop on the list of packages of interest \styfmt{babel}, \styfmt{polyglossia}, \styfmt{mlp}, or
% \styfmt{ngerman}, and set or not \cs{iffc@languagemode@detected} flag as a result.}
% Check to see if \styfmt{babel}, \styfmt{polyglossia}, \styfmt{mlp}, or \styfmt{ngerman} packages have been
% loaded, and if yes set \styfmt{fmtcount} in multiling. First we define some \cs{fc@check@for@multiling}
% macro to do such action where \texttt{\#1} is the package name, and \texttt{\#2} is a callback.
%    \begin{macrocode}
\def\fc@check@for@multiling#1:#2\@nil{%
  \@ifpackageloaded{#1}{%
    #2\@set@mulitling@fmtcount
  }{}%
}
%    \end{macrocode}
% Now we define \cs{fc@loop@on@multiling@pkg} as an iterator to scan whether any of \styfmt{babel},
% \styfmt{polyglossia}, \styfmt{mlp}, or \styfmt{ngerman} packages has been loaded, and if so set multilingual
% mode.
%    \begin{macrocode}
\def\fc@loop@on@multiling@pkg#1,{%
  \def\@tempb{#1}%
  \ifx\@tempb\@nnil
%    \end{macrocode}
% We have reached the end of the loop, so stop here.
%    \begin{macrocode}
     \let\fc@loop@on@multiling@pkg\@empty
  \else
%    \end{macrocode}
% Make the \cs{@ifpackageloaded} test and break the loop if it was positive.
%    \begin{macrocode}
     \fc@check@for@multiling#1\@nil
     \iffc@languagemode@detected
       \def\fc@loop@on@multiling@pkg##1\@nil,{}%
     \fi
  \fi
  \fc@loop@on@multiling@pkg   
}
%    \end{macrocode}
% Now, do the loop itself, we do this at beginning of document not to constrain the order of loading
% \styfmt{fmtcount} and the multilingual package \styfmt{babel}, \styfmt{polyglossia}, etc.:
%    \begin{macrocode}
\AtBeginDocument{%
  \fc@loop@on@multiling@pkg babel:,polyglossia:,ngerman:\FCloadlang{ngerman},\@nil,
%    \end{macrocode}
% In the case that no multilingual package (such as
% \styfmt{babel}/\styfmt{polyglossia}/\styfmt{ngerman}) has been loaded, then we go to multiling
% if a language has been loaded by package option.
%    \begin{macrocode}
   \unless\iffc@languagemode@detected\iffmtcount@language@option
%    \end{macrocode}
% If the multilingual mode has not been yet activated, but a language option has been passed to
% \styfmt{fmtcount}, we should go to multilingual mode. However, first of, we do some sanity check, as this
% may help the end user understand what is wrong: we check that macro \cs{languagename} is defined, and
% activate the multilingual mode only then, and otherwise fall back to default legacy mode.
%    \begin{macrocode}
      \ifcsundef{languagename}%
      {%
         \PackageWarning{fmtcount}{%
            `\protect\languagename' is undefined, you should use a language package such as babel/polyglossia
             when loading a language via package option. Reverting to default language.
         }%
         \@setdef@ultfmtcount
      }{%
        \@set@mulitling@fmtcount
        
%    \end{macrocode}
% Now, some more checking, having activated multilingual mode after a language option has been passed to
% \styfmt{fmtcount}, we check that the \styfmt{fmtcount} language definitions corresponding to
% \cs{languagename} have been loaded, and otherwise fall \cs{languagename} back to the latest
% \styfmt{fmtcount} language definition loaded.
%    \begin{macrocode}
        \@FC@iflangloaded{\languagename}{}{%
%    \end{macrocode}
% The current \cs{languagename} is not a \styfmt{fmtcount} language that has been previously loaded. The
% correction is to have \cs{languagename} let to \cs{fc@mainlang}. Please note that, as
% \cs{iffmtcount@language@option} is true, we know that \texttt{fmtcount} has loaded some language.
%    \begin{macrocode}
            \PackageWarning{fmtcount}{%
               Setting `\protect\languagename' to `\fc@mainlang'.\MessageBreak
               Reason is that `\protect\languagename' was `\languagename',\MessageBreak
               but `\languagename' was not loaded by fmtcount,\MessageBreak
               whereas `\fc@mainlang' was the last language loaded by fmtcount ;
            }%
            \let\languagename\fc@mainlang
         }%
      }%
   \else
       \@setdef@ultfmtcount
   \fi\fi
}
%    \end{macrocode}
% \changes{3.01}{2014/12/03}{Substitute \cs{textsuperscript} for \cs{fc@textsuperscript}, and define
% \cs{fc@textsuperscript} as \cs{fup} when defined at beginning of document, or as \cs{textsuperscript}
% otherwise}
%    \begin{macrocode}
\AtBeginDocument{%
   \ifcsundef{FBsupR}{\let\fc@textsuperscript\textsuperscript}{\let\fc@textsuperscript\fup}%
}
%    \end{macrocode}
% Backwards compatibility:
%    \begin{macrocode}
\let\@ordinal=\@ordinalM
\let\@ordinalstring=\@ordinalstringM
\let\@Ordinalstring=\@OrdinalstringM
\let\@numberstring=\@numberstringM
\let\@Numberstring=\@NumberstringM
%    \end{macrocode}
\iffalse Local variables: \fi
\iffalse mode: docTeX     \fi
\iffalse End:             \fi
